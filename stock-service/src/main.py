from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Optional, Union
import sys
import os

# Add the src directory to Python path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from index_maker import create_custom_index
from utils.csv_reader import read_index_fields_from_csv
from utils.benchmark_utils import get_benchmark_historical_data
import os
import pandas as pd

app = FastAPI(
    title="Stock Index Advisor API",
    description="API for creating custom stock indices and fetching market data",
    version="1.0.0"
)

# Add CORS middleware to allow frontend requests
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"],  # Next.js default ports
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models for request/response validation
class IndexCreationRequest(BaseModel):
    indexSize: int
    indexCurrency: str
    indexStartAmount: int
    indexStartDate: str
    indexEndDate: str
    selectedCountries: List[str]
    selectedSectors: List[str]
    selectedIndustries: List[str]
    selectedKPIs: Dict[str, List[str]]
    selectedStocks: List[str]
    weight: str = "cap" 

class IndexCreationResponse(BaseModel):
    success: bool
    message: str
    result: Optional[Dict] = None
    error: Optional[str] = None

@app.get("/")
async def root():
    """Root endpoint to check if API is running"""
    return {"message": "Stock Index Advisor API is running!", "version": "1.0.0"}

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "stock-index-advisor"}

@app.get("/api/index-fields")
async def get_index_fields():
    """Get all available index fields (countries, sectors, industries, KPIs, companies) from CSV files"""
    try:
        # Read fields from CSV files generated by field_maker.py
        fields_data = read_index_fields_from_csv()
        return fields_data
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch index fields: {str(e)}")

@app.get("/api/benchmark-data")
async def get_benchmark_data(symbols: str, startDate: str = None, endDate: str = None, startAmount: float = 1000, currency: str = "USD"):
    """Get historical data for selected benchmark symbols"""
    try:
        # Parse symbols from comma-separated string
        symbols_list = [s.strip() for s in symbols.split(',') if s.strip()]
        
        if not symbols_list:
            raise HTTPException(status_code=400, detail="No symbols provided")
        
        # Validate currency
        if currency.upper() not in ["USD", "EUR"]:
            raise HTTPException(status_code=400, detail="Currency must be USD or EUR")
        
        # Fetch benchmark data
        benchmark_data = get_benchmark_historical_data(
            symbols=symbols_list,
            start_date=startDate,
            end_date=endDate,
            start_amount=startAmount,
            currency=currency.upper()
        )
        
        return benchmark_data
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch benchmark data: {str(e)}")

@app.get("/api/benchmark-risk-return")
async def get_benchmark_risk_return():
    """Return risk/return metrics from benchmarks.csv for scatter plot."""
    try:
        # Path to benchmarks.csv under src/utils/fields
        fields_dir = os.path.join(os.path.dirname(__file__), 'utils', 'fields')
        csv_path = os.path.join(fields_dir, 'benchmarks.csv')

        if not os.path.exists(csv_path):
            raise HTTPException(status_code=404, detail="benchmarks.csv not found")

        df = pd.read_csv(csv_path, dtype=str, keep_default_na=False, na_filter=False)

        # Safely coerce numeric columns; missing become None
        def to_float_safe(x):
            try:
                xv = float(x)
                if pd.isna(xv):
                    return None
                return xv
            except Exception:
                return None

        result = []
        for _, row in df.iterrows():
            item = {
                "name": row.get("name"),
                "symbol": row.get("symbol"),
                "type": row.get("type"),
                "return_eur": to_float_safe(row.get("return_eur")),
                "return_usd": to_float_safe(row.get("return_usd")),
                "risk_eur": to_float_safe(row.get("risk_eur")),
                "risk_usd": to_float_safe(row.get("risk_usd")),
            }
            result.append(item)

        return {"benchmarks": result}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to load benchmark risk/return: {str(e)}")

@app.post("/api/create-index", response_model=IndexCreationResponse)
async def create_index(request: IndexCreationRequest):
    """Create a custom stock index based on provided parameters"""
    try:
        # Call the existing create_custom_index function
        result = create_custom_index(
            index_size=request.indexSize,
            currency=request.indexCurrency,
            start_amount=request.indexStartAmount,
            start_date=request.indexStartDate,
            end_date=request.indexEndDate,
            countries=request.selectedCountries,
            sectors=request.selectedSectors,
            industries=request.selectedIndustries,
            kpis=request.selectedKPIs,
            stocks=request.selectedStocks,
            weight=request.weight
        )
        
        # Convert dataframes to JSON-serializable format
        index_data = result["index_df"]
        constituent_weights = result["constituent_weights"]
        risk_return = result.get("risk_return")
        
        return IndexCreationResponse(
            success=True,
            message=f"Index created successfully with {len(index_data)} data points",
            result={
                "index_data": index_data,
                "total_data_points": len(index_data),
                "constituent_weights": constituent_weights,
                "risk_return": risk_return,
            }
        )
            
    except Exception as e:
        return IndexCreationResponse(
            success=False,
            message="Failed to create index",
            error=str(e)
        )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

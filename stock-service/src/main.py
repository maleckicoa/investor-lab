from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Optional, Union
import sys
import os

# Add the src directory to Python path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from index_maker import create_custom_index
from utils.csv_reader import read_index_fields_from_csv
from utils.benchmark_utils import get_benchmark_historical_data

app = FastAPI(
    title="Stock Index Advisor API",
    description="API for creating custom stock indices and fetching market data",
    version="1.0.0"
)

# Add CORS middleware to allow frontend requests
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"],  # Next.js default ports
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models for request/response validation
class IndexCreationRequest(BaseModel):
    indexSize: int
    indexCurrency: str
    indexStartAmount: int
    indexStartDate: str
    indexEndDate: str
    selectedCountries: List[str]
    selectedSectors: List[str]
    selectedIndustries: List[str]
    selectedKPIs: Dict[str, List[str]]
    selectedStocks: List[str]

class IndexCreationResponse(BaseModel):
    success: bool
    message: str
    result: Optional[Dict] = None
    error: Optional[str] = None

@app.get("/")
async def root():
    """Root endpoint to check if API is running"""
    return {"message": "Stock Index Advisor API is running!", "version": "1.0.0"}

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "stock-index-advisor"}

@app.get("/api/index-fields")
async def get_index_fields():
    """Get all available index fields (countries, sectors, industries, KPIs, companies) from CSV files"""
    try:
        # Read fields from CSV files generated by field_maker.py
        fields_data = read_index_fields_from_csv()
        return fields_data
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch index fields: {str(e)}")

@app.get("/api/benchmark-data")
async def get_benchmark_data(symbols: str, startDate: str = None, endDate: str = None, startAmount: float = 1000, currency: str = "USD"):
    """Get historical data for selected benchmark symbols"""
    try:
        # Parse symbols from comma-separated string
        symbols_list = [s.strip() for s in symbols.split(',') if s.strip()]
        
        if not symbols_list:
            raise HTTPException(status_code=400, detail="No symbols provided")
        
        # Validate currency
        if currency.upper() not in ["USD", "EUR"]:
            raise HTTPException(status_code=400, detail="Currency must be USD or EUR")
        
        # Fetch benchmark data
        benchmark_data = get_benchmark_historical_data(
            symbols=symbols_list,
            start_date=startDate,
            end_date=endDate,
            start_amount=startAmount,
            currency=currency.upper()
        )
        
        return benchmark_data
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch benchmark data: {str(e)}")

@app.post("/api/create-index", response_model=IndexCreationResponse)
async def create_index(request: IndexCreationRequest):
    """Create a custom stock index based on provided parameters"""
    try:
        # Call the existing create_custom_index function
        result = create_custom_index(
            index_size=request.indexSize,
            currency=request.indexCurrency,
            start_amount=request.indexStartAmount,
            start_date=request.indexStartDate,
            end_date=request.indexEndDate,
            countries=request.selectedCountries,
            sectors=request.selectedSectors,
            industries=request.selectedIndustries,
            kpis=request.selectedKPIs,
            stocks=request.selectedStocks,
            
        )
        
        # Convert dataframes to JSON-serializable format
        index_data = result["index_df"]
        constituent_weights = result["constituent_weights"]
        
        return IndexCreationResponse(
            success=True,
            message=f"Index created successfully with {len(index_data)} data points",
            result={
                "index_data": index_data,
                "total_data_points": len(index_data),
                "constituent_weights": constituent_weights
            }
        )
            
    except Exception as e:
        return IndexCreationResponse(
            success=False,
            message="Failed to create index",
            error=str(e)
        )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
